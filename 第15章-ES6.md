## 介绍

ES6 - 即 ES5 的语法升级版本，不兼容 IE 低版本（有些也不支持IE9和IE10），可以通过 babel 将 ES6 转换为 ES5 ，所以可以放心的书写 ES6 的代码

## 1、let、const 

##### let

- let 使用块级作用域  

  *块级作用域  -  即 { } 内就是一个作用域*

  *ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。*

- let 不能再一个作用域中声明两个标识符相同的变量  

  ```js
  let a = 10
  let a = 20    
  //  报错
  ```

  ```js
  let a = 10
  var a = 20    
  //  报错
  ```

  ```js
  function(a){
      let a = 10   
  }  
  //  报错,和函数参数重复
  ```
- let 也会变量提升 ,但不会初始化提升

##### const

- const 具有 let 具有的所有特性

- const 在初始化时必须要进行赋值

- const 定义的为常量，**不允许被重新赋值**（引用类型不改变引用地址，则不会报错），通常使用大写字母表示（ 用小写也没错 ）

  ```js
  const a = 10
  a = 20  //  报错
  
  const b = [1,2,3]
  b.push(4)   // 不报错，const 定义的引用类型，引用地址不变，则不会报错
  ```

##### let、const变量提升

JS 中所有的声明（var/let/const/function/class），都存在提升

- let 定义的变量存在  暂存死区  ， 禁止了在声明的位置前访问
- 暂时死区：let声明的变量位置到当前let作用域的的顶部

```js
let x = 'global'
{
    console.log(x) //Uncaught ReferenceError: Cannot access 'x' before initialization
    let x = 1
}
```

**使用ES6定义变量的好处**

```js
// 1、使用 var
console.info(a)   // undefined 如果我们不想定义a，此时还是进行了定义
if(false){
    var a = 10
}

// 2、使用 let
console.info(a)  // 报错
if(false){
    let a = 10
}

console.info(a)  // 报错
if(true){
    let a = 10
}
```

##### 顶层作用域

- ES5 中顶层作用域为 window
- ES6 中顶层作用域为 global （无法被访问到）

 使用 ES6 的`let` 、`const`和`class`声明的全局变量不再被挂载到window上，而被挂载到 ES6 的顶层作用域 global 上。（global 作用域无法被访问到）

```js
var a = 1
console.info(window.a)  // 1

let b = 2
console.info(window.b)  // undefined
```

## 2、解构赋值